<!DOCTYPE html>
<html>
<head>
<meta charset="utf8" />
<title>Чего мелочиться, надо начинать не с байтов, а с битов</title>
</head>
<body>

<table><tr><td style="vertical-align:top;">
<h1>Чего мелочиться, надо начинать не с байтов, а с битов</h1>
</td><td style="vertical-align:top;">
<a href="at-byte-level.htm">Как распарсить текст от уровня байтов</a>
<br />
&nbsp;
</td></tr></table>


<dl>


<dt>цепочка битов</td>
<dd>
представим текст в виде длинной (ну как длинной? имеющей длину) линейной цепочки битов.
<br />
Саму цепочку <strong>назовём</strong> S. Или <strong>обозначим</strong> как S.  Или <strong>поименуем</strong> как S. Или <strong>будем говорить, что</strong> цепочка это S.
<br />
количество битов в цепочке обозначим N.
<br />
Длину цепочки в битах <strong>обозначим</strong> L<sub>S</sub> = N.
<br />
n-ный по счёту бит обозначим как S<sub>n</sub>
<br />
целое число, обозначающее длину цепочки будет занимать &lceil; log<sub>2</sub>N &rceil; битов
<br />
операцию стандартного двоичного кодирования обозначим как E
<br />
Операцию подсчёта длины записи в битах обозначим L<sub>E</sub> (length of encoding)
<br />
L<sub>E(S)</sub> = L<sub>E(L<sub>S</sub>)</sub> + N * L<sub>E(S<sub>n</sub>)</sub>
<br />
длина записи одного бита L<sub>E(S<sub>n</sub>)</sub> = 1
</dd>


<dt>позиция бита в цепочка битов</dt>
<dd>
это целое неотрицательное число. Причем длина таких чисел в битах (в стандартной двоичной кодировке/записи) 
не превышает &lceil; log<sub>2</sub>N &rceil;
<br />
Позицию обозначим P
<br />
Длину позиции обозначим как L<sub>P</sub>
</dd>


<dt>сегмент в цепочке битов</dt>
<dd>
Это несколько смежных позиций в цепочке. Сегмент, слитная подпоследовательность, span, subsequence.
<br />
Сегмент можно определить указанием начала сегмента и длины сегмента (в битах)
<br />
количество битов в сегменте - это целое число, в записи которого битов тоже log<sub>2</sub>N
<br />
Сегмент обозначим как W (мнемонической связи никакой, это не "слово" (word), 
ассоциация была - две галочки, отмечающие начало и конец)
<br />
длину сегмента (при записи/кодировании <strong>представления</strong> сегмента в бинарном виде стандартным способом)
<br />
обозначим L<sub>W</sub>= <span title="длина позиции">L<sub>P</sub></span> + <span title="длина в битах целого числа, описыващего количество битов в сегменте">log<sub>2</sub>N</span>
</dd>


<dt>множество позиций битов в цепочке битов представленное в виде массива позиций</dt>
<dd>
Чтобы записать множество, запишем количество элементов множества, а потом сами элементы (которые имеют фиксированную длину)
<br />
в памяти такая запись будет занимать
<br />
<span title="длина в битах целого числа, описыващего количество позиций в множестве" style="background-color:orange">log<sub>2</sub><span title="позиций в множестве" style="background-color:yellow">M</span></span>
+ <span title="M = количеству элементов во множестве. Может операцию взятия мощности ввести?" style="background-color:yellow">M</span> * 
<span title="длина в битах одной позиции">L<sub>P</sub></span>
<br />
M &le; N
</dd>

<dt>множество позиций бита в цепочке битов</dt>
<dd>
Множество состоит из элементов, каждый элемент - позиция.
<br />
записывать/кодировать множество позиций можно разными способами (как минимум тремя)
<br />
- множество позиций битов в цепочке битов в виде массива позиций
<br />
- множество позиций битов в цепочке битов в виде массива сегментов
<br />
- множество позиций битов в цепочке битов в виде комбинации массива позиций и массива сегментов

<div style="background-color:lightblue">
незря, всё-таки, математики придумывали разные короткие символы для обозначения новых понятий,
описывать которые словами дольше, чем запомнить один новый символ. 
Компьютеры отобрали возможность создавать новые символы
и легко размещать символы на плоскости в разных позициях по отношению друг к другу,
выражая таким образом отношения между символами
</div>

<br />
<font style="color:red">Какое из нескольких представлений выбирать, выбирать то или иное (ту или иную запись) множества позиций?</font>
<br />
нужно выбирать запись, которая занимает меньшее количество места
<br />
для этого должен быть способ (метод класса, функция-член) для того,
чтобы определять/вычислять длину представления в каждом варианте
<br />
можно сделать у каждого множества метод "создать наиболее компактное представление"
<br />
<font style="color:red">по какому алгоритму будет работать такой метод?</font>
<br />
он посчитает количество смежных позиций, смежных групп позиций, вычислит размеры записи в том или ином варианте
<br />
<font style="color:red">а какие варианты есть и как из перебирать?</font>
</dd>

<div style="background-color:lightblue">
с другой стороны, я понимаю тех, кто пробует читать математические тексты.
Читать такие тексты неудобно, так как значения символов не сразу запоминаются,
а только при частом (и по делу) использовании символов
</div>


</dl>

Допустим, что библиотека работающая с 
<br />
битами, позициями, сегментами битов, множествами позиций
<br />
закодирована. <font style="color:red">Что при помощи неё можно делать?</font>
<br />
<br />

А то ведь можно много (сколько, кcтати?) усилий потрать на её написание.
<br />
сделать сериализацию самих битовых объектов, сериализацию метаинформации о том, что в файле начиная с какого смещения
<br />
кроме файлов сделать хранение в СУБД и вообще много чего (конкретнее - что именно "много чего"?).

<br />
<br />
Абстрактные синтаксические конструкции <strong>представлены/закодированы</strong> 
<s>в исходном тексте</s> в исходной последовательности битов S наборами позиций
<br />
(что-то не верится. Вот есть арифметическое кодирование, там символы могут быть закодированы частью бита,
а символы это как раз один из вариантов тех самых абстрактных синтаксических конструкций)
<br />
частью бита - в том смысле, что бит может определять сразу несколько символов, идущих подряд,
в зависимости от предыдущего контекста.
<br />
<br />
Абстрактные синтаксические конструкции представялются/кодируются символами (именно поэтому они "абстрактные", а не "терминальные символы").
<br />
а символы кодируются битами (но не по принципу 1 символ - целое количество битов)
<br />
<br />
Что мешает кодировать абстрактные синтаксические конструкции непосредственно (без промежуточной записи символами)?
<br />
нуу, в памяти компьютера они как раз битами и закодированы.
<br />
Глифы символов - компактное это визуальное представление,
а глифы для значений битов - некомпактное (хотя если посмотреть на QR-коды...)
<br />
QR-коды труднее распознаются человеком (не работает алгоритм выделения существенных деталей,
так как все детали существенные)
<br />
<br />
смирится (-ли) с тем, что тексты записываются символами (а не битами) и писать парсер для символов, а не для битовых цепочек?
<br />
разбор напрямую из битов мог бы устранить некоторые ошибки раскодирования
(<font style="color:red">а это нужно? какова "значимость"?</font> смешно говорить об устранении ошибок при арифмметическом кодировании?
а если специальное помехозащищенное кодирование - то ошибки восстанавливать уже не нужно, этим занимается кодирование.
<br />
есть ли выигрыш от убирания разделений на защиту от помех и на ошибки при парсинге?
Не зря же изначально разделяли. С другой стороны, с тех пор мы стали <strong>подкованнее</strong> (более оснащены знаниями и инструментами).
вообще-то надо бы ошибки классифицировать, составить "модель угроз"...
)

</body>
</html>

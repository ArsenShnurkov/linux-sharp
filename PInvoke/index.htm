<!DOCTYPE html>
<html>
<head>
<meta charset="utf8" />
<title>PInvoke</title>
</head>
<body>

<table><tr><td style="vertical-align:top;">
<h1>PInvoke</h1>
</td><td style="vertical-align:top;">
<a href="../index.htm">Разработка на C# под linux</a>
<br />
&nbsp;
</td></tr></table>

надо что-нибудь такое потестить:
<br />
1. Просто вызов C-функций из C# кода.
<br />
это позволит проверить как работает мэппинг имён dll-ок на имена .so-шек, а так же поиск .so-шек через LD_LIBRARY_PATH
<br />
<br />
2. Вызов делегатов из C-кода
<br />
сначала мы как-то попанаем в кправляемый код, потом вызываем функции из C, а они долго работают и всё это время вызывают делегаты из C#
<br />
то есть на примере с freeciv - из C# кода запускам главную функцию сервера (надо переоформить код exe-шника в .dll,
а плагин реализующий ИИ будет вызывать C# делегаты).
<br />
откуда плагин узнает нужные значения указателей на делегаты?
<br />
плагин может быть слинкован с mono-рантаймом и вызывать его функции.
<br />
Загрузка рантайма произойдёт динамически (то есть выяснится, что рантайм уже загружен)
<br />
<br />
Т.е. общая схема mono-code.exe вызывает c-code.engine, вызывает c-code-plugin, вызывает mono-engine
<br />
<br />
Здесь мне не ясно, как библиотека вызовет код mono.
<br />
<br />
Что-нибудь мешает загрузить mono-code.exe из c-code.engine.exe (пропатчив его)?
<br />
<br />
<a href="http://www.mono-project.com/docs/advanced/embedding/">http://www.mono-project.com/docs/advanced/embedding/</a>
<br />
<br />
done by linking `libmono’

<br />
<br />
в принципе, и из клиента ведь можно создать домен? Потом функция main через PInvoke затянет данные, выставит коллбеки и можно будет реагировать...

</body>
</html>

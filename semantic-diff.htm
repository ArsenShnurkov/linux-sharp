<!DOCTYPE html>
<html>
<head>
<meta charset="utf8" />
<title>Семантическая разница</title>
</head>
<body>

<table><tr><td valign="top">
<h1>Семантическая разница</h1>
</td><td valign="top">
<a href="index.htm">Разработка на C# под linux</a>
<br />
&nbsp;
</td></tr></table>

<a href="http://martinfowler.com/bliki/SemanticDiff.html">http://martinfowler.com/bliki/SemanticDiff.html</a>
<br />
<dl>

<dt>artifacts (артифакты)</dt>
<dd>текстовые и бинарные файлы</dd>

<dt>editing tools</dt>
<dd>tool allow to perform operations with artefact</dd>

<dt>объектная модель</dt>
<dd>в процессе редактирования, утилита редактирования создаёт объектную модель, над которой выполняет операции.
<br />
то есть утилита редактирования гарантированно умеет преобразовывать артфакт в объектную модель и обратно (возможно, что не весь артефакт, а работая с ним по частям, если он большой)
</dd>

<dt>xml</dt>
<dd>
это такой промежуточный уровень. У него есть своя модель и свой набор операций над моделью.
<br />
то есть операции более высокой модели выражаются в терминах операций над более низким уровнем модели (в данном случае - моделью XML),
<br />
а операции над XML выражаются в терминах операций редактирования модели текста
</dd>

<dt>модель текста</dt>
<dd>
даже тут есть варианты, может это что-то простое, типа StringBuilder с операциями Remove, Insert, Replace
<br />
а может это сложное типа модели текста LibreOffice
</dd>

<dt>version control systems (системы управления версиями)</dt>

<dl>change (изменение)</dl>
<dd>often referred to as diffs from the command that can produce them in Unix.</dd>

<dl>difference</dl>
<dd>Ну надо же, применяем мы change, а когда присматриваемся к различиям, то это и не change вовсе,
а "set of differences"...
<br />
почему это не одно и то же? Как выявляют differences?
</dd>


<dt>diff (and merge) algorithms (алгоритм создания патча, алгоритм применения патча)</dt>
<dd></dd>


<dt>semantic diff</dt>
<dd>A semantic diff would <strong>understand</strong> the purpose of the change, rather than just the effect.
<br />
Extract Method refactoring in a tool
<br />
With current tools they see the change in the program text, but they don't know that I did a refactoring. 
<br />
when I examine the diff between the two versions  it can't show me the changes
in such a way that highlights the refactoring.
<br />
This also can make merges more awkward than it might if it actually knew what I was doing.
</dd>

<dt>understanding</dt>
<dd>Это когда выдвигают гипотезы и ищут им подтверждения (а в идеале - аксиомы (факты) и доказательства (выводы)</dd>

</dl>

<h2>Сценарии</h2>
Сценарии, где нужно выделять разницу:
<br />
1) патчинг XML
<br />
2) парчинг AST
<br />
3) сравнение дерева директорий
<br />
4) сравнение химических соединений (в биоинформатике)

<h2>Модификация последовательностей</h2>
Ну есть же пример, как это делать в простом случае (когда используется только одна модель (модель текста), а не иерархия моделей). Распиши как это работает и сделай по-аналогии.

<h3>longest common subsequence (LCS)</h3>
Если у нас деревья, то где этот алгоритм может понадобиться? При сравнении (нормализованных - отсортированных в определенном порядке, например) списков дочерних узлов?
<br />
Given strings A and B, the LCS problem is to find the longest string C that is a common subsequence of A and B.
When this is done, the file comparison output can be generated by simultaneously scanning strings A, B, and C,
flagging characters that appear in A but not in C one way, and flagging those that appear in B but not in C another way. 
<br />
The LCS method has strong appeal: It is a simple formal statement of the problem that yields good results. 
<br />
<br />
it has two basically different disadvantages. The first is that it is not necessarily the correct formalization of the problem. 
In the two examples below, the longest common subsequence is probably not what is desired. 
<br />
Minimization of the number of inserts plus deletes is not a good formulation of the problem
since the differences between any two strings can be trivially displayed as one deleted string and one inserted one.
<br />
(<font style="color:red">а что если в стоимость операции добавлять длины аргументов операции? может тогда это станет более хорошей формулировкой?</font>)
<br />
In the second example, the LCS method does not find a moved block of characters (it never does), but the "better" display both shows the moved block and finds edits within the blocks. 
<br />
The author's opinion is that there is no "correct" formulation of the problem, just as there is no "correct" way to determine which of two equivalent algebraic expressions is simpler. 
<br />
(<font style="color:red">но можно же сравнить по длине алгебраического выражения или по суммарной сложности выполнения операций алгебраического выражения</font>,
<font style="color:gray">пф. ты сделай и покажи людям, а до тех пор они тебя слушать не будут...</font>)
<br />
<br />
The second disadvantage of the LCS method concerns the computational problems associated with it [1, 6, 7]. In the worst case, it can take time 
O(mn)-that is, time proportional to the product of the lengths of the two strings. 


<h3>1978, Heckel (где могут быть использованы дифы)</h2>
<a href="http://documents.scribd.com/docs/10ro9oowpo1h81pgh1as.pdf">http://documents.scribd.com/docs/10ro9oowpo1h81pgh1as.pdf</a>
<br />
computationally efficient (with time linear in the file length)
<br />
For most applications the algorithm isolates differences similar to those isolated by the longest common subsequence.

<br />
<br />
We make two observations:
<br />
1. A line that occurs once and only once in each file must be the same line (unchanged but possibly moved). This "finds" most lines and thus excludes them from further consideration.
<br />
2. If in each file immediately adjacent to a "found" line pair there are lines identical to each other, these lines must be the same line. Repeated application will "find" sequences of unchanged lines. 

<h3>1983, Tichy (стоимость операций, покрытия=coverages)</h3>
<a href="http://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1377&context=cstech">http://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1377&context=cstech</a>
<br />
Что хорошего в этой статье? Есть одна строка, есть другая строка, они ищут минимальное покрытие, которое переносит первую строку во вторую.
С чем я не разобрался - так это с тем, могут ли они копировать одни и те же буквы дважды из одного исходного места в два конечных места.
<br />
<br />
Есть идея, что параметры (конкретные их значения) - это последовательность микроопераций (по вставке одной буквы).
<br />
И если искать в пространстве микроопераций, то алгоритм нахождения всех микроопераций будет в точности A*.
<br />
проблема в том, что микрооперации после свёртывания дают операции боолее высокого уровня, оценки которых отличаются от суммы оценок микроопераций
(ну значит изначально были выбраны неправильные микрооперации. Надо простроить стоимости операций начиная от уровня инструкций процессора (или MSIL достаточно? или операций над .Net API?)
проблема с более высокими операциями - у них пропадает простота аргументов, и это затрудняет подбор аргументов)
<br />
"The storage space required for a move is negligible compared to thet of an add command"
<br />
Unfortunately, the definition of an LCS is such that the n cannot be included in the LCS.
<br />
<br />
Если у нас операции модификации определены иерархично (операция из более высокой модели преобразуется в набор операций более низкой модели),
то и изменения наверное можно разделить на уровни и выявлять не сразу, а постепенно (по уровням),
то есть сначала найти самые простые изменения на уровне текста,
на их основе сообразить, какие изменения были проведены на уровне XML,
а отсюда понять, какие изменения прикладного уровня имелись в виду.

<h2>Иерахчиность в данных</h2>
"finding the optimal matching for unordered trees is known to be NP-hard"

<h2>1977, Stanley Selkow</h2>
1977, Stanley M. Selkow, The tree-to-tree editing problem
<br />
<br />
2013, Байцерова Юлия Сергеевна, под руководством Вояковская Н.Н., Проверка избыточности и минимизация множества тестов 
<br />
<a href="http://se.math.spbu.ru/SE/YearlyProjects/2013/YearlyProjects/2013/445/445-Baytserova-report.pdf">http://se.math.spbu.ru/SE/YearlyProjects/2013/YearlyProjects/2013/445/445-Baytserova-report.pdf</a>
<pre>
Метрика Стэнли Селкова введена им для вычисления расстояния между
помеченными упорядоченными деревьями. Помеченным упорядоченным деревом он
называет непустое конечное множество T с функцией маркировки λ, такое что:
1) Т имеет особую вершину, называемую корнем дерева
2) Остальные вершины (исключая корень) разделены на m≥0 непересекающихся
множеств Т1, … , Тm, и каждое из этих множеств является деревом. Эти
множества называются поддеревьями дерева Т
3) С каждой из вершин v ϵ Т связана метка λ(v). Метка для корня дерева Т
обозначается как λ(Т). Пусть даны два дерева: А и В с поддеревьями А1, … , Аm
и В1, … , Вn соответственно, тогда А и В равны, если λ(А) = λ(В), m = n и Аi
 = Вi

для 1 ≤ i ≤ m
Далее вводятся так называемые операции редактирования:
1) Операция замены метки L(si
, sk), примененная к дереву Т, дает дерево T* с λ(Т*)
= sk и поддеревьями Т1, … , Тm
2) Операция вставки I(A) для 0 ≤ i ≤ m и дерева А, примененная к дереву Т в i-ой
позиции, дает дерево Т* с λ(Т*) = sj
 и поддеревья Т1, … , Тi
, А, Тi+1, … , Тm
3) Операция удаления D(Ti) для 1 ≤ i ≤ m, примененная к Т в i-ой позиции, дает
дерево Т* с λ(Т*) = sj
 и поддеревьями Т1, … , Тi-1, Тi+1, … , Тm
С каждой операцией редактирования связывается неотрицательная стоимость
следующим образом. С каждой парой меток (si
, sj) связывается стоимость СL(si
, sj)
применения операции L(si
, sj). Для каждой метки si
 выражениями СI(si) и СD(si)
обозначаются стоимости применения операций I(T) и D(T) соответственно, где Т – дерево
с одной вершиной и λ(Т) = si
. Для произвольного дерева Т:
СI(Т) = ΣvϵT CI(λ(v)) и СD(Т) = ΣvϵT CD(λ(v)) 

Пусть есть деревья А и В и множество последовательностей операций
редактирования, которые, будучи примененными к дереву А, дают дерево, равное В.
Тогда вычисление расстояния между деревьями сводится к вычислению функции δ(А, В),
обозначающую минимальную сумму стоимостей для каждой последовательности.
Сложность алгоритма: O(|TA|×|TB|), где |TA|, |TB| - число листьев деревьев ТА и ТВ
соответственно. 
</pre>

<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://web.cs.wpi.edu/~sms/cs3133/index.html">http://web.cs.wpi.edu/~sms/cs3133/index.html</a>




<h2>1989, Zhang, Shasha</h2>
1989, Kaizhong Zhang and Dennis Shasha, Simple fast algorithms for the editing distance between trees and related problems
<br />
<a href="http://www.grantjenks.com/wiki/_media/ideas:simple_fast_algorithms_for_the_editing_distance_between_tree_and_related_problems.pdf">http://www.grantjenks.com/wiki/_media/ideas:simple_fast_algorithms_for_the_editing_distance_between_tree_and_related_problems.pdf</a>
<br />
<br />
<a href="http://cs.nyu.edu/cs/faculty/shasha/papers/">http://cs.nyu.edu/cs/faculty/shasha/papers/</a>
<br />
Этот Shasha ещё вполне живой и в сознании, у него есть email и можно ему написать (только писать надо так, чтобы ему захотелось ответить)
<br />
<br />
<a href="http://www.youtube.com/watch?v=hwiks-n7vso">http://www.youtube.com/watch?v=hwiks-n7vso</a>

<h2>1996, Chawathe</h2>
Our emerged change distilling algorithm is based on the tree differencing algorithm of Chawathe et al. (1996).
<br />
<a href="http://ilpubs.stanford.edu:8090/115/1/1995-46.pdf">http://ilpubs.stanford.edu:8090/115/1/1995-46.pdf</a>
<br />
<br />
delta tree



<h2>Gabriel Valiente</h2>
<a href="http://www.cs.upc.edu/~valiente/publications.html">http://www.cs.upc.edu/~valiente/publications.html</a>
<br />
<br />
2001, Gabriel Valiente. An Efficient Bottom-Up Distance between Trees.
<br />
<a href="http://www.lsi.upc.es/~valiente/abs-spire-2001.pdf">http://www.lsi.upc.es/~valiente/abs-spire-2001.pdf</a>


<h2>Что особенного в XML</h2>
There are some specific aspects of XML which deserve mention:
<br />
1) attributes, which are guaranteed to have unique names within a node; 
<br />
2) IDs, which are guaranteed to be unique within a document.
<br />
<br />
но атрибуты могут быть необязательными (а обязательными могут?), или может поменяться схема, и тогда атрибут добавится или пропадёт.


<h2>Иерархичность в операциях</h2>
У утилиты редактирования (редактирования чего? артефакта, например текстового файла) есть некая объектная модель (например абстрактное синтаксическое дерево (abstract-syntax-tree, AST) текста).
<br />
с объектами этой модели можно выполнять операции. Операции преобразуют артефакт (возможно в нескольких местах)
<br />
<br />
Утилита создания патча должа:
<br />
- знать про объектную модель утилиты редактирования (и список операций на той модели)
<br />
- уметь преобразовывать артефакт в его объектную модель и обратно
<br />
- уметь выявлять операции, глядя на две версии (версии артефакта? или глядя на две версии объектной модели?)
<br />
<br />
Если есть несколько уровней моделей, то должен быть способ описывать связь между операциями разных уровней (реализация операций более высокого уровня
в терминах операции более низкого уровня). Угу, например C# (для анализа доступный через reflection).
<br />
то есть факт - операция может быть описана в виде формальных символов (обозначим простейшие операции, опишем более сложные в терминах простейших)
<br />
<br />
Здесь не очень ясно, как вписывается утилита редактирования с её операциями,
ведь именно операции этой утилиты приводят к изменениям нижнего уровня (например увеличение отступа блока текста)
<br />
в то же время, модель утилиты редактирования не включена в стек моделей (прикладная-xml-байты). <font style="color:gray">Ну дополни, в чем проблема-то, сделай "прикладная-xml-редактор-байты"
(надо бы сравнить с OSI, потому что у меня нет уровней "символов" и "концов строк" между байтами и редактором)</font>
<br />



<br />
Если есть два разных артефакта, то можно поискать кратчайшую цепочку операций, превращающих один артефакт в другой артефакт.
<br />
что значит "кратчайшая"? Операции имеют вес, например длину записи в .diff-файле (или время выполнения. Не очень понятно, важно ли время. что лучше - одна трудоёмкая операция или много простых)
<br />
то есть поискать цепочку операций с минимальным суммарным весом.
<br />
так как набор операций ограничен и описан в модели, можно было бы поудмать о переборе все возможные вариантов цепочек (как в алгоритме A*)
<br />
неограниченными операции делает добавление параметров операции (например, если это операция набора (вставки) текста, то количество вариантов вставляемого текста бесконечно),
тут важен подбор параметров (и непонятно, как его проводить, даже глядя на артефакты или модели.
<br />
<br />
Имея описание операций, можно ли выявлять (обнаруживать) их последствия?
<br />
Как восставновить отдельную операцию, если их было много?
<br />
<br />
Есть что-то общее с парсингом (там тоже могут быть разные варианты восстановления AST)
<br />
Есть что-то общее с распознаванием образов (на входе объектные модели (как структуры из элементов), а 
надо создать описание разницы (как последовательный набор операций (с параметрами) над элементами и над связями элементов))
<br />
Есть что-то общее с экспертными систмами (там построение и проверка гипотез)



<h2>Нужен ли ручной парсинг XML?</h2>
It's too late to analyse two XMLs by their DOM models. Information about linking of XML nodes to original character positions is already lost
<br />
so with no information about linking, it's impossible to convert editing changes in XML text into editing changes in XML nodes
<br />
<br />
Ну распарси вручную, будет у тебя информация о том, какие редактирующие изменения текста повлияли на какие элементы XML-модели.
<br />
(только где гарантия, что редактирующие измнения текста ты правильно выделил? Кругом гипотезы)

<h2>Графы в общем виде</h2>

2004, Fausto Giunchiglia; Mikalai Yatskevich; Enrico Giunchiglia, Efficient semantic matching
<br />
&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.103.9186&rank=4">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.103.9186&rank=4</a>


<h2>Как угробить много времени неясно ради каких целей</h2>
Чего пытаемся добиться, сначала придумав XML-формат,
а потом разрабатывая утилиты для него?
<br />
Сценарий 1 (use case) - редактирование списка пакетов и версий пакетов в файле packages.config
<br />
ведь в моём частном конкретном случае есть всего-лишь список пакетов, линейный. А в линейном списке,
который к тому же множество (то есть нет дубликатов и не важен порядок), найти различия - тривиальная задача
- отсортировать два списка и сравнить. Что лишнее - удалить, чего не хватает - добавить, ...
(<font style="color:gray">конечно это не совсем множество, а множество узлов направленного ациклического графа зависимостей, но учет зависимостей и порядка установки берет на себя утилита nuget, пусть она и разбирается</font>)
<br />
Сценарий 2 (use case) - редактирование файла machine.config
<br />
В принципе то же самое. Если не трогать остальное содержимое файла, то то, что меня волнует - это список провайдеров БД
<br />
Казалось бы - напиши простую частичную грамматику, которая будет конкретно этот участок выделять и обрабатывай наздоровье.
<br />
(<font style="color:gray">ну а если такой секции нет, то что?</font>)
<br />
Вот, есть же простые adhoc-решения. Нет надо выдумать несуществующий университет Subsurface Habbitation University, к нему несуществующую кафедру Nascent Intelligence Department и от его имени опубликовать докторскую на отвлечённую тему. Ну не смешно?

<br />
<br />
<a href="http://le2i.cnrs.fr/IMG/publications/Efficient%20XML%20Structural%20Similarity%20Detection%20using%20Sub-tree%20Commonalities.pdf">http://le2i.cnrs.fr/IMG/publications/Efficient XML Structural Similarity Detection using Sub-tree Commonalities.pdf</a>
<br />
2007, Joe Tekli; Richard Chbeir; Kokou Yetongnon, Efficient XML Structural Similarity Detection using Sub-tree Commonalities
</body>
</html>
